#! /usr/bin/perl -w#	die "Use this to add data to a tree at each nodeUSAGE: <tree file> <temp tree output> <mapping list> <poplist> > redirect\n" unless lp71lp@ARGVrp71rp;lp70lp$file, $output, $map, $poplistrp70rp= lp69lp@ARGVrp69rp;chomp lp68lp$filerp68rp;chomp lp67lp$outputrp67rp;chomp lp66lp$maprp66rp;chomp lp65lp$poplistrp65rp;open lp64lpIN, "<${file}"rp64rp or die "Can't open $file\n";while lp63lp$line=<IN>rp63rp{	chomp lp62lp$linerp62rp;	$newline = "$newline"."$line";}close lp61lpINrp61rp;open lp60lpIN, "<${map}"rp60rp or die "Can't open $map\n";while lp59lp$line=<IN>rp59rp{	chomp lp58lp$linerp58rp;	$maplist{$line}++;}close lp57lpINrp57rp;open lp56lpIN, "<${poplist}"rp56rp or die "Can't open $poplist\n";while lp55lp$line=<IN>rp55rp{	chomp lp54lp$linerp54rp;	lp53lp$isolate, $hab, $poprp53rp = split lp52lp"\t", $linerp52rp;	$pophash{$pop}{$isolate}++;}close lp51lpINrp51rp;$count=1;$lnum=1;	@pieces = split lp50lp"", $newlinerp50rp;	$total=@pieces;	while lp49lp$totalrp49rp{		$total=$total-1;		if lp48lp$pieces[$total] eq "\rp48rp"rp47rp{			$matching = "rp"."${count}"."rp";			$unmatched{$count}++;			$printhash{$lnum}=$matching;			$lnum++;#			print "$matching\n";			$count++;		} elsif $pieces[$total] eq "\lp46lp"rp46rp{			$last = lp45lprp45rp;			foreach $match lp44lpsort {$b <=> $a} keys %unmatchedrp44rp{				if lp43lp$lastrp43rp{					$newunmatched{$match}++;				} else{					$matching = "lp"."$match"."lp";					#print "$matching\n";					$printhash{$lnum}=$matching;					$lnum++;					$last++;				}			}			%unmatched = %newunmatched;			%newunmatched = lp42lprp42rp;		} else {			#print "$pieces[$total]\n";			$printhash{$lnum}=$pieces[$total];			$lnum++;		}	}open lp41lpOUT, ">${output}"rp41rp or die "Can't open $output\n";foreach $lnum lp40lpsort {$b <=> $a} keys %printhashrp40rp{	print OUT "$printhash{$lnum}";}print OUT "\n";close lp39lpOUTrp39rp;$newline = lp38lprp38rp;open lp37lpIN, "<${output}"rp37rp or die "Can't open $output\n";while lp36lp$line=<IN>rp36rp{	chomp lp35lp$linerp35rp;	next unless lp34lp$linerp34rp;	$newline = "$newline"."$line";}close lp33lpINrp33rp;#put isolate to the right of every nodeforeach $pop lp32lpsort keys %pophashrp32rp{	$previousno=lp31lprp31rp;	$goodtree=lp30lprp30rp;	print "Working on pop $pop\n";	$count=1;	lp29lp@rightparensrp29rp = $newline =~/lp28lprp[0-9]+rp?rp28rp/g;	foreach $paren lp27lp@rightparensrp27rp{		lp26lp$norp26rp = $paren=~/rplp25lp[0-9]+rp25rprp/;		lp24lp$subtreerp24rp = $newline =~/lp${no}lplp23lp.+rp23rprp${no}rp/;		lp22lp@sizerp22rp = split lp21lp"", $subtreerp21rp;		$number = @size;		$remove=lp20lprp20rp;		foreach $isolate lp19lpkeys %{$pophash{$pop}}rp19rp{			$remove++ unless lp18lp$subtree=~/${isolate}:/rp18rp;		}		unless lp17lp$removerp17rp{			if lp16lp$previousnorp16rp{				if lp15lp$number < $previousnorp15rp{					$previousno = $number;					$goodtree=$subtree;				}			} else {				$previousno = $number;				$goodtree= "lp"."$no"."lp"."$subtree"."rp"."$no"."rp";			}		}	}	$goodtree =~s/lp[0-9]+lp/\lp14lp/g;	$goodtree =~s/rp[0-9]+rp/\rp14rp/g;#	print  "${goodtree}\n";$playline= $goodtree;$playline =~s/lp[0-9]+lp/>/g;$playline =~s/rp[0-9]+rp/>/g;$playline =~s/,/>/g;lp13lp@isosrp13rp = split lp12lp">", $playlinerp12rp;foreach $isolate lp11lp@isosrp11rp{        next unless lp10lp$isolate=~/^.+:.+$/rp10rp;        lp9lp$isonamerp9rp = $isolate=~/^\*lp8lp.+?rp8rp:.+$/;        print "$isoname\t$pop\n" if lp7lp$maplist{$isoname}rp7rp;#        lp6lp$leftmem, $rightmemrp6rp = $newline =~/^lp5lp.*rp5rp${isolate}lp4lp.*rp4rp$/;#        $str1= "${leftmem}lp3lpX:0.00100,${isolate}rp3rp:0.00100${rightmem}";#        $str1 =~s/lp[0-9]+lp/\lp2lp/g;#        $str1 =~s/rp[0-9]+rp/\rp2rp/g;#        print OUT1 "${str1}\n";#        close lp1lpOUT1rp1rp;#        $count++;}}
